#!/usr/bin/env python3
#
# SPDX-License-Identifier: MIT
#
# This file is formatted with Python Black
#

from typing import Any, Dict, List, Optional, Tuple

import enum
import logging
import pathlib
import struct

import hidtools
import hidtools.hid

import gi
from gi.repository import GObject

import ratbag
from ratbag.util import as_hex

logger = logging.getLogger(__name__)


RECEIVER_IDX = 0xFF
REPORT_ID_SHORT = 0x10
REPORT_ID_LONG = 0x11


class FeatureName(enum.Enum):
    ROOT = 0x0000
    FEATURE_SET = 0x0001
    DEVICE_INFO = 0x0003
    DEVICE_NAME = 0x0005
    PAGE_RESET = 0x0020
    BATTERY_LEVEL_STATUS = 0x1000
    BATTERY_VOLTAGE = 0x1001
    LED_SW_CONTROL = 0x1300
    KBD_REPROGRAMMABLE_KEYS = 0x1B00
    SPECIAL_KEYS_BUTTONS = 0x1B04
    MOUSE_POINTER_BASIC = 0x2200
    ADJUSTIBLE_DPI = 0x2201
    ADJUSTIBLE_REPORT_RATE = 0x8060
    COLOR_LED_EFFECTS = 0x8070
    RGB_EFFECTS = 0x8071
    ONBOARD_PROFILES = 0x8100
    MOUSE_BUTTON_SPY = 0x8110


class OnboardProfile:
    class MemoryType(enum.Enum):
        G402 = 0x01

    class ProfileType(enum.Enum):
        G402 = 0x01
        G303 = 0x02
        G900 = 0x03
        G915 = 0x04

    class MacroType(enum.Enum):
        G402 = 0x01

    class Mode(enum.Enum):
        NO_CHANGE = 0x00
        ONBOARD = 0x01
        HOST = 0x02

    class Sector(enum.Enum):
        USER_PROFILES_G402 = 0x0000
        ROM_PROFILES_G402 = 0x0100

        END_OF_PROFILE_DIRECTORY = 0xFFFF
        ENABLED_INDEX = 2


# the following crc computation has been provided by Logitech
def crc(data):
    def clamp(v):
        return v & 0xFFFF  # because we can't force python to use 16bit

    crc = 0xFFFF  # seed
    for v in data:
        tmp = clamp((crc >> 8) ^ v)
        crc = clamp(crc << 8)
        quick = clamp(tmp ^ (tmp >> 4))
        crc = clamp(crc ^ quick)
        quick = clamp(quick << 5)
        crc = clamp(crc ^ quick)
        quick = clamp(quick << 7)
        crc = clamp(crc ^ quick)
    return crc


class Feature(object):
    def __init__(self, name, index, type):
        self.name = name
        self.index = index
        self.type = type


class Color:
    def __init__(self, r, g, b):
        self.red, self.green, self.blue = r, g, b

    def __str__(self):
        return f"rgb({self.red},{self.green},{self.blue})"


class Profile(object):
    """
    A HID++ 2.0 profile on a device.

    .. attribute:: address

        The memory address where this profile resides

    .. attribute:: enabled

        ``True`` if enabled, ``False`` otherwise

    .. attribute:: name

        The name of the profile. This name is never ``None``, the driver fills
        in an autogenerated value if no name is configured on the device.

    .. attribute:: dpi

        A duple of DPI values configured for this profile

    .. attribute:: data

        The initial data this profile was created from. This data is constant
        for the life of the profile and can be used to restore the profile to
        its original state.

    .. attribute:: report_rate

        The report rate in Hz
    """

    def __init__(self, addr):
        self.address = addr
        self.enabled = False
        self.name = f"Profile {self.address}"
        self.data = None

    def from_data(self, data):
        self.data = data
        offset = 0

        # This is parsed in stages to make it a bit easier to debug
        format = "BBB"
        sz = struct.calcsize(format)
        vals = iter(struct.unpack_from(format, data, offset=offset))
        offset += sz
        self.report_rate = 1000 / max(1, next(vals))
        self.default_dpi = next(vals)
        self.switched_dpi = next(vals)

        # DPI is le, not BE!
        format = "<HHHHH"
        sz = struct.calcsize(format)
        self.dpi = struct.unpack_from(format, data, offset=offset)
        offset += sz

        format = "BBB"
        sz = struct.calcsize(format)
        r, g, b = struct.unpack_from(format, data, offset=offset)
        offset += sz
        self.colors = Color(r, g, b)

        format = "BB"
        sz = struct.calcsize(format)
        vals = iter(struct.unpack_from(format, data, offset=offset))
        offset += sz
        self.power_mode = next(vals)
        self.angle_snapping = next(vals)

        offset += 10  # reserved

        # le, not BE!
        format = "<HH"
        sz = struct.calcsize(format)
        vals = iter(struct.unpack_from(format, data, offset=offset))
        offset += sz
        self.powersafe_timeout = next(vals)
        self.poweroff_timeout = next(vals)

        # next are 16 4-byte button bindings, times two
        format = ">" + "I" * 16 * 2
        sz = struct.calcsize(format)
        vals = iter(struct.unpack_from(format, data, offset=offset))
        offset += sz

        # next is the profile name
        # If any of the values is 0xff we're not using it
        sz = 16 * 3
        name = data[offset : offset + sz]
        offset += sz
        try:
            name.index(b"\xff")
        except ValueError:
            # we're not using the default name, so let's decode this
            self.name = name.decode("utf-8")

        # next are 11 bytes per leds, times 2 leds, times 2
        # next are 2 unused bytes
        # last 2 bytes are the 16-bit crc

    @classmethod
    def from_sector(cls, data, index):
        addr_offset = 4 * index
        addr = int.from_bytes(data[addr_offset : addr_offset + 2], byteorder="big")
        if addr == OnboardProfile.Sector.END_OF_PROFILE_DIRECTORY.value:
            return None

        # profile address sanity check
        expected_addr = OnboardProfile.Sector.USER_PROFILES_G402.value | (index + 1)
        if addr != expected_addr:
            logger.error(
                f"profile {index}: expected address 0x{expected_addr:04x}, have 0x{addr:04x}"
            )

        enabled = data[addr_offset + OnboardProfile.Sector.ENABLED_INDEX.value] != 0

        p = Profile(addr)
        p.enabled = enabled
        return p

    def __str__(self):
        return (
            f"{self.name}: {self.report_rate}Hz, "
            f"{self.default_dpi}/{self.switched_dpi}dpi "
            f"{[x for x in self.dpi]} "
            f"{self.colors} "
            f"timeouts:{self.powersafe_timeout}/{self.poweroff_timeout}"
        )


class Hidpp20Device(GObject.Object):
    """
    A HID++2.0 device

    .. attribute:: index

        The device index for the Logitech receiver

    .. attribute:: supported_requests

        A list of supported requests (``REPORT_ID_SHORT`, ``REPORT_ID_LONG``)

    .. attribute:: protocol_version

        A (major, minor) tuple with the HID++ 2.0 protocol version

    .. attribute:: features

        A dict using :class:`FeatureName` as key and a :class:`Feature` as
        value. This dict includes only named features (listed in
        :class:`FeatureName`, other features may be supported by the device
        but are ignored.

    .. attribute:: profiles

        A list of :class:`Profile` instances
    """

    def __init__(self, hidraw_device, device_index):
        GObject.Object.__init__(self)
        self.index = device_index
        self.hidraw_device = hidraw_device

    @property
    def name(self):
        return self.hidraw_device.name

    @property
    def path(self):
        return self.hidraw_device.path

    def start(self):
        supported = self._get_supported_report_types(
            self.hidraw_device.report_descriptor
        )
        required = (REPORT_ID_SHORT, REPORT_ID_LONG)
        if not (set(supported) & set(required)):
            raise ratbag.SomethingIsMissingError(
                self.name, self.path, "HID++ short/long reports"
            )

        self.supported_requests = supported

        self._init_protocol_version()
        self._init_features()
        self._init_profiles()

    def _get_supported_report_types(self, report_descriptor):
        rdesc = hidtools.hid.ReportDescriptor.from_bytes(report_descriptor)

        supported = []

        for report in rdesc.input_reports.values():
            for field in [
                f for f in report.fields if (f.usage_page & 0xFF000000) == 0xFF000000
            ]:
                if field.report_ID in [REPORT_ID_SHORT, REPORT_ID_LONG]:
                    supported.append(field.report_ID)

        return set(supported)

    def _init_protocol_version(self):
        # Get the protocol version and our feature set
        version = QueryProtocolVersion(self).run()
        logger.debug(f"protocol version {version.major}.{version.minor}")
        if version.major < 2:
            raise ratbag.SomethingIsMissingError(
                self.name, self.path, "Protocol version 2.x"
            )
        self.protocol_version = (version.major, version.minor)

    def _init_features(self):
        feature_set = QueryRootGetFeature(
            self, FeatureName.FEATURE_SET
        ).run()  # PAGE_FEATURE_SET
        logger.debug(feature_set)
        feature_count = QueryFeatureSetCount(self, feature_set).run()
        logger.debug(feature_count)

        features = []
        for idx in range(feature_count.count):
            query = QueryFeatureSetId(self, feature_set, idx).run()
            logger.debug(query)

            fid = query.feature_id
            ftype = query.feature_type

            try:
                name = FeatureName(fid)
                features.append(Feature(name, idx, type))
                logger.debug(f"device has feature {name.name}")
            except ValueError:
                # We're intentionally skipping unknown features here, if we can't
                # name them we don't know how to handle them
                pass

        self.features = dict(zip([f.name for f in features], features))

    def _init_profiles(self):
        if FeatureName.ONBOARD_PROFILES not in self.features:
            raise ratbag.SomethingIsMissingError(
                self.name, self.path, "HID++2.0 feature ONBOARD_PROFILES"
            )

        desc_query = QueryOnboardProfilesDesc(self).run()
        logger.debug(desc_query)
        if desc_query.memory_model_id != OnboardProfile.MemoryType.G402.value:
            raise ratbag.SomethingIsMissingError(
                self.name,
                self.path,
                f"Unsupported memory model {desc_query.memory_model_id}",
            )
        if desc_query.macro_format_id != OnboardProfile.MacroType.G402.value:
            raise ratbag.SomethingIsMissingError(
                self.name,
                self.path,
                f"Unsupported macro format {desc_query.macro_format_id}",
            )
        try:
            OnboardProfile.ProfileType(desc_query.profile_format_id)
        except ValueError:
            raise ratbag.SomethingIsMissingError(
                self.name,
                self.path,
                f"Unsupported profile format {desc_query.profile_format_id}",
            )

        sector_size = desc_query.sector_size

        mode_query = QueryOnboardProfilesGetMode(self).run()
        logger.debug(mode_query)
        if mode_query.mode != OnboardProfile.Mode.ONBOARD.value:
            raise ratbag.SomethingIsMissingError(
                self.name, self.path, f"Device not in Onboard mode ({mode_query.mode})"
            )

        # profiles are in a format known to us, yay. Let's read the whole
        # sector
        mem_query = QueryOnboardProfilesMemRead(
            self,
            OnboardProfile.Sector.USER_PROFILES_G402.value,
            offset=0,
            sector_size=sector_size,
        ).run()
        logger.debug(mem_query)

        self.profiles = []

        if mem_query.crc_valid:
            for idx in range(desc_query.profile_count):
                profile = Profile.from_sector(mem_query.data, idx)
                if not profile:
                    continue

                profile_query = QueryOnboardProfilesMemRead(
                    self, profile.address, offset=0, sector_size=sector_size
                ).run()
                logger.debug(profile_query)
                if not profile_query.crc_valid:
                    # FIXME: libratbag reads the ROM instead in this case
                    logger.error(f"CRC validation failed for profile {idx}")
                    continue

                profile.from_data(profile_query.data)
                logger.debug(profile)
                self.profiles.append(profile)

    def send(self, bytes):
        """
        Send the bytestream to the device
        """
        self.hidraw_device.send(bytes)

    def recv_sync(self):
        """
        Wait until the device replies and return that bytestream
        """
        return self.hidraw_device.recv()

    def send_and_recv_sync(self, bytes):
        """
        Send a bytestream to the device and wait for a reply that matches our
        message. Note that messages that are not a reply to our message are
        discarded.
        """
        self.send(bytes)

        while True:
            reply = self.recv_sync()
            if reply is None:
                break

            if (reply.sub_id, reply.address) == (message.sub_id, message.address):
                break

        return reply


class Hidpp20Driver(ratbag.drivers.Driver):
    """
    Implementation of the Logitech HID++ 2.0 protocol.

    Driver options supported:

        - ``Buttons``: the number of buttons exported by the device
        - ``DeviceIndex``: the HID++ device index
        - ``Leds``: the number of LEDs exported by device
        - ``ReportRate``: fixed report rate
        - ``Quirk``: the quirk to apply to this device, one of ``G305``, ``G602``

    :param config: A dict of the (lowercase) driver options
    :param quirk: ``None`` or one of :class:`Quirk`
    """

    NAME = "Logitech HID++2.0"

    class Quirk(enum.Enum):
        """Available quirks for devices"""

        G305 = "G305"
        G602 = "G602"

    def __init__(self):
        super().__init__()

        self.device = None

    def probe(self, device, info, config):
        self.config = config
        for key in ("Buttons", "DeviceIndex", "Leds", "ReportRate"):
            try:
                val = config[key]
                config[key.lower()] = val
            except KeyError:
                pass

        quirk = config.get("Quirk", None)
        if quirk is not None:
            try:
                self.quirk = [x for x in Hidpp20Driver.Quirk if x.value == quirk][0]
            except IndexError:
                raise ratbag.ConfigError(f"Invalid quirk value '{quirk}'")

        # Usually we default to the receiver IDX and let the kernel sort it
        # out, but some devices need to have the index hardcoded in the data
        # files
        self.index = config.get("deviceindex", RECEIVER_IDX)
        self.hidraw_device = ratbag.drivers.Rodent.from_device(device)
        self.device = Hidpp20Device(self.hidraw_device, self.index)

        for rec in self.recorders:

            def cb_logtx(device, data):
                rec.log_tx(data)

            def cb_logrx(device, data):
                rec.log_rx(data)

            self.hidraw_device.connect("data-from-device", cb_logrx)
            self.hidraw_device.connect("data-to-device", cb_logtx)
            rec.init(
                {
                    "name": self.device.name,
                    "driver": "hidpp20",
                    "path": self.device.path,
                    "report_descriptor": self.hidraw_device.report_descriptor,
                }
            )

        self.ratbag_device = ratbag.Device(self, self.device.path, self.device.name)
        self.ratbag_device.connect("commit", self.cb_commit)
        self.device.start()
        # Device probe/start was successful if no exception occurs. Now fill in the
        # ratbag device.
        for idx, profile in enumerate(self.device.profiles):
            p = ratbag.Profile(self.ratbag_device, idx, name=profile.name)
            for dpi_idx, dpi in enumerate(profile.dpi):
                ratbag.Resolution(p, dpi_idx, (dpi, dpi))
        self.emit("device-added", self.ratbag_device)

    def cb_commit(self, device):
        pass


def load_driver(driver_name):
    """
    :meta private:
    """
    assert driver_name == "hidpp20"
    return Hidpp20Driver()

################################################################################
#
# Below is the implementation of the HID++2.0 protocol
#
# We have a set of Query objects that the device calls, each sends a request
# to the device and waits for the reply. To simplify the implementation, the
# Query class implements most of the functionality, each individual query just
# needs to change the bitst out and parse the bits that came back.
#
# The instance then sets self.whatever for each whatever in the reply, so the
# caller looks like this:
#
#    query = QuerySomeThing(device).run().
#    if query.some_field != 3:
#        ...
#


class Query(object):
    """
    A query against the device, consisting of a request and a reply from the
    device.

    .. attribute: query

        The bytes sent to the device

    .. attribute: reply

        The bytes received from  the device

    :param device: The device to query

    """

    LONG_MESSAGE_LENGTH = 20
    SHORT_MESSAGE_LENGTH = 7

    report_id: int = REPORT_ID_SHORT  # override if need be
    page: Optional[
        int
    ] = None  # Override in subclass, self.page has precedence over class.page
    command: Optional[
        int
    ] = None  # Override in subclass, self.page has precedence over class.page

    # a list of tuples that are parsed before parse_reply, see
    # ratbag.util.attr_from_data for details
    reply_format: Optional[List[Tuple[str, str]]] = None

    def __init__(self, device):
        # We have dynamic queries that change per-device, so we use self.page
        # before class.page
        cls = type(self)
        page = getattr(self, "page", cls.page)
        command = getattr(self, "command", cls.command)

        if getattr(self, "reply_format", None) is None:
            self.reply_format = cls.reply_format

        assert page is not None
        assert command is not None
        assert page <= 0xFF
        assert command <= 0xFF

        self.device = device
        query_len = {
            REPORT_ID_LONG: Query.LONG_MESSAGE_LENGTH,
            REPORT_ID_SHORT: Query.SHORT_MESSAGE_LENGTH,
        }[cls.report_id]
        self.query = [0] * query_len
        self.query[0] = cls.report_id
        self.query[1] = device.index
        self.query[2] = page
        self.query[3] = command

    @property
    def query_params(self):
        """
        Return the query parameters. Consider this a read-only variable, the
        returned value is a list slice and modifying that slice does not
        modify the actual query. Instead, do either of ::

            self.query_params = [1, 2, 3]  # 0-padded to message length
            self.set_query_params([1, 2, 3], offset=0)
        """
        return self.query[4:]

    @query_params.setter
    def query_params(self, params):
        assert len(params) <= len(self.query_params)
        self.query = (
            self.query[:4] + params + [0] * (len(self.query_params) - len(params))
        )

    def set_query_params(self, new_values, offset=0):
        """
        Set the query parameters from the given offset to the new values,
        leaving all others in place
        """
        assert len(new_values) + offset <= len(self.query_params)
        for v in new_values:
            self.query[4 + offset] = v
            offset += 1

    def set_query_param_be(self, value, bits=16, offset=0):
        assert bits in [32, 16, 8]
        shift = bits - 8
        while True:
            v = (value >> shift) & 0xFF
            self.query_params[offset] = v
            offset += 1
            if shift == 0:
                break
            shift -= 8

    @property
    def reply_params(self):
        return self.reply[4:]

    def _autoparse(self):
        if not self.reply_format:
            return

        self._autostr = ""

        endian = ">"  # default to BE

        logger.debug(f"autoparse: reply: {as_hex(self.reply_params)}")
        ratbag.util.attr_from_data(self, self.reply_format, self.reply_params, offset=0)

        self._autostr = " ".join(
            [
                f"{name}: {getattr(self, name)}"
                for _, name in self.reply_format
                if name not in ["_", "?"]
            ]
        )

    def parse_reply(self):
        """
        Override this in the subclass if :attr:`reply_format` autoparsing is
        insufficient. Parse the given bytes and set the required instance
        attributes. :attr:`reply` is set with the bytes from the reply.

        If the caller calls :meth:`schedule_repeat` during ``parse_reply``,
        same command is issued again once ``parse_reply`` completes and
        ``parse_reply`` is called with the new reply data.
        """
        pass

    def schedule_repeat(self):
        """
        Call this from parse_reply if the same command should be issued again
        to the device. This will call into parse_reply again
        """
        self._repeat = True

    def run(self):
        """
        Send the request to the device, wait synchronously for the reply to
        return.

        :return: this Query object
        """
        # address is 4 bit MBS: subcommand, 4 bit LSB: SW identifier so the
        # device knows who to respond to. Kernel uses 0x1
        assert self.query[3] & 0xF == 0, "Error: SW address is already set"
        self.query[3] |= 0x8

        self._repeat = True
        while self._repeat:
            self._repeat = False
            self.device.send(bytes(self.query))
            self.reply = self.device.recv_sync()

            if self.reply[2] == 0x8F:
                raise QueryError(self.device, self.bytes)

            self._autoparse()
            self.parse_reply()
        return self

    def __str__(self):
        try:
            return f"{type(self).__name__}: {self._autostr}"
        except AttributeError:
            return str(super())


class QueryError(Exception):
    """
    An exception raised when a :class:`Query` failed with a HID++ error.

    .. attribute: device

        The device the error occured on

    .. attribute: bytes

        The raw bytes of the error message

    .. attribute: page

        The command page

    .. attribute: command

        The command id
    """

    def __init__(self, device, bytes):
        self.device = device
        self.bytes = bytes
        self.page = bytes[3]
        self.command = bytes[4]


class QueryProtocolVersion(Query):
    """
    .. attribute: major


    .. attribute: minor
    """

    page = FeatureName.ROOT.value
    command = 0x10  # GET_PROTOCOL_VERSION
    reply_format = [
        ("B", "major"),
        ("B", "minor"),
    ]

    def __init__(self, device):
        super().__init__(device)
        self.version = (0, 0)


class QueryRootGetFeature(Query):
    page = FeatureName.ROOT.value
    command = 0x00  # GET_FEATURE
    reply_format = [
        ("B", "feature_index"),
        ("B", "feature_type"),
        ("B", "feature_version"),
    ]

    def __init__(self, device, feature):
        super().__init__(device)
        self.feature = feature
        self.feature_index = None
        self.feature_type = None
        self.feature_version = None
        fbytes = int.to_bytes(feature.value, 2, "big", signed=False)
        self.set_query_params(list(fbytes))

    def __str__(self):
        return (
            f"{type(self).__name__}: {self.feature.name} (0x{self.feature.value:04x}) at index {self.feature_index}, "
            f"type {self.feature_type} "
            f"version {self.feature_version}"
        )


class QueryFeatureSetCount(Query):
    page = None  # Note: dynamic page depending on feature index
    command = 0x00  # GET_COUNT
    reply_format = [("B", "count")]

    def __init__(self, device, root_feature_query):
        self.page = root_feature_query.feature_index
        super().__init__(device)
        self.feature = root_feature_query.feature
        self.count = None

    def parse_reply(self):
        # feature set count does not include the root feature as documented
        # here:
        # https://6xq.net/git/lars/lshidpp.git/plain/doc/logitech_hidpp_2.0_specificati
        if self.feature == FeatureName.FEATURE_SET:
            self.count += 1

    def __str__(self):
        return f"{type(self).__name__}: {self.feature.name} (0x{self.feature.value:04x}) count {self.count}"


class QueryFeatureSetId(Query):
    page = None  # Note: dynamic page depending on feture index
    command = 0x10  # GET_FEATURE_ID
    reply_format = [
        ("H", "feature_id"),
        ("B", "feature_type"),
    ]

    def __init__(self, device, root_feature_query, index):
        self.page = root_feature_query.feature_index
        super().__init__(device)
        self.feature = root_feature_query.feature
        self.feature_id = None
        self.feature_type = None
        self.query_params = [index]

    def __parse_reply(self):
        feature_value = int.from_bytes(self.reply_params[:2], byteorder="big")
        self.feature_id = feature_value
        self.feature_type = self.reply_params[2]


class QueryOnboardProfilesDesc(Query):
    page = None  # feature index
    command = 0x00
    reply_format = [
        ("B", "memory_model_id"),
        ("B", "profile_format_id"),
        ("B", "macro_format_id"),
        ("B", "profile_count"),
        ("B", "profile_count_oob"),
        ("B", "button_count"),
        ("B", "sector_count"),
        ("H", "sector_size"),
        ("B", "mechanical_layout"),
        ("B", "various_info"),
        ("ccccc", "_"),
    ]

    def __init__(self, device):
        self.page = device.features[FeatureName.ONBOARD_PROFILES].index
        super().__init__(device)

    def parse_reply(self):
        self.has_g_shift = (self.mechanical_layout & 0x03) == 0x02
        self.has_dpi_shift = ((self.mechanical_layout & 0x0C) >> 2) == 0x02
        self.is_corded = (self.various_info & 0x07) in [1, 4]
        self.is_wireless = (self.various_info & 0x07) in [2, 4]

    def __str__(self):
        return (
            f"{type(self).__name__}: memmodel {self.memory_model_id}, "
            f"profilefmt {self.profile_format_id}, macrofmt {self.macro_format_id}, "
            f"profilecount {self.profile_count} oob {self.profile_count_oob}, "
            f"buttons {self.button_count}, "
            f"sectors {self.sector_count}@{self.sector_size} bytes, "
            f"mechlayout {self.mechanical_layout}, various {self.various_info}, "
            f"gshift {self.has_g_shift} dpishift {self.has_dpi_shift}, "
            f"corded {self.is_corded} wireless {self.is_wireless}"
        )


class QueryOnboardProfilesGetMode(Query):
    page = None  # feature index
    command = 0x20
    reply_format = [("B", "mode")]

    def __init__(self, device):
        self.page = device.features[FeatureName.ONBOARD_PROFILES].index
        super().__init__(device)


class QueryOnboardProfilesMemRead(Query):
    report_id = REPORT_ID_LONG
    page = None
    command = 0x50

    def __init__(self, device, sector, offset=0, sector_size=16):
        assert sector <= 0xFFFF
        self.page = device.features[FeatureName.ONBOARD_PROFILES].index
        super().__init__(device)
        s = int.to_bytes(sector, 2, "big", signed=False)
        self.set_query_params(s, offset=0)
        self._initial_offset = offset
        self._offset = offset
        self._sector_size = sector_size
        self._prep_for_run()
        self.data = bytes()
        self.crc_valid = False

    def _prep_for_run(self):
        off = int.to_bytes(self._offset, 2, "big", signed=False)
        self.set_query_params(off, offset=2)

    def parse_reply(self):
        # Shorten back to offset bytes so we overwrite the last 16 bytes, see
        # comment below
        if self._offset < len(self.data):
            self.data = bytes(list(self.data[: self._offset]))
        self.data += self.reply_params
        self._offset += 16
        if self._offset < self._sector_size:
            # The firmware replies with an ERR_INVALID_ARGUMENT if we try to
            # read past sector_size, so when we are left with less than 16
            # bytes to read we start reading from sector_size - 16
            if self._sector_size - self._offset < 16:
                self._offset = self._sector_siZe - 16
            self._prep_for_run()
            self.schedule_repeat()

        # The CRC is stored in the last two bytes of the sector, so we only
        # calculate it if we read those two bytes *and* we have enough data to
        # actually caculate the crc
        if len(self.data) >= self._sector_size:
            expected_crc = self.data[self._sector_size - 2 : 2]
            self.crc_valid = crc(list(self.data)) == int.from_bytes(
                expected_crc, byteorder="big"
            )

    def __str__(self):
        return f"{type(self).__name__}: {len(self.data)} bytes from offset {self._initial_offset} (crc: {self.crc_valid})"
